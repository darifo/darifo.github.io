---
title: 【力扣算法题】生命游戏
author: Darifo
Github: 'https://github.com/darifo'
Pages: 'https://darifo.github.io/'
date: 2020-04-02 18:56:09
categories:
- LeetCode
tags:
- 算法
- 数组
- 矩阵
---

> 来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/game-of-life
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。


给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态：1 即为活细胞（live），或 0 即为死细胞（dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：

1.如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；

2.如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；

3.如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；

4.如果死细胞周围正好有三个活细胞，则该位置死细胞复活；


根据当前状态，写一个函数来计算面板上所有细胞的下一个（一次更新后的）状态。下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。

案例：
```
输入： 
[
  [0,1,0],
  [0,0,1],
  [1,1,1],
  [0,0,0]
]

输出：
[
  [0,0,0],
  [1,0,1],
  [0,1,1],
  [0,1,0]
]
```

### 解题

由题目意思可知，在矩阵（二维数组）中，1是活细胞，0是死细胞，在特定条件下，活细胞会死，死细胞会活，而题目要求是求出这个矩阵面板上所有细胞的下一状态，即只做一次条件匹配，更新后的细胞存活和死亡状态，不妨看一下案例输入矩阵，第一行第二个细胞是活细胞，它的上下左右斜八个方向（边缘细胞少于八个方向），只有一个活细胞（第二行第三个），即命中题目条件1，所以这个活细胞会死掉，同理，可以推算其他细胞在进行一次条件匹配后，是存活还是死亡。

那么，具体逻辑应该是怎样呢。

#### 方法一：复制参考矩阵

时间复杂度：O(mn)  m,n为矩阵行列长度

空间复杂度：O(mn) mn为复制矩阵所需空间

#### 方法二：带复合状态的遍历搜寻及恢复

时间复杂度：O(mn)  m,n为矩阵行列长度
空间复杂度：O(1)


##### 详细流程见代码注释：

```java

package com.company.darifo.solutions;

public class GameOfLife {

    public static void main(String[] args) {
        GameOfLife gameOfLife = new GameOfLife();

        int[][] b = {
                {0, 1, 0},
                {0, 0, 1},
                {1, 1, 1},
                {0, 0, 0}
        };
        printMap(b);
        gameOfLife.funcOne(b);
        printMap(b);

        int[][] d = {
                {0, 1, 0},
                {0, 0, 1},
                {1, 1, 1},
                {0, 0, 0}
        };
        printMap(d);
        gameOfLife.funcTow(d);
        printMap(d);
    }

    private static void printMap(int[][] map) {
        System.out.println("矩阵打印如下：");
        for (int[] chars : map) {
            for (int aChar : chars) {
                System.out.print(aChar);
                System.out.print('\t');
            }
            System.out.print('\n');
        }
    }

    /**
     * todo 方法一 复制数组
     */
    public void funcOne(int[][] board) {
        // 定义搜索方向坐标偏移量数组
        int[] nb = {0, 1, -1};

        // 初始化面板行列
        int rows = board.length;
        int cols = board[0].length;

        // 复制一份数组，用于参考
        int[][] copyBoard = new int[rows][cols];
        for (int rr = 0; rr < rows; rr++) {
            System.arraycopy(board[rr], 0, copyBoard[rr], 0, cols);
        }

        // 遍历每一个细胞
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {

                // 初始化本细胞周围存活细胞数
                int aliveNb = 0;

                //开始从本细胞不同方向去搜寻周边细胞 ,根据坐标偏移量数组nb[0,1,-1]实现八个方向搜索
                for (int x = 0; x < 3; x++) {
                    for (int y = 0; y < 3; y++) {
                        // 取出坐标偏移量，以获得周围细胞数据
                        // 横坐标纵坐标偏移量不能同时为0 否则就没意义（没有移动）
                        if (!(nb[x] == 0 && nb[y] == 0)) {
                            // 横坐标偏移量
                            int r = i + nb[x];
                            // 纵坐标偏移量
                            int c = j + nb[y];

                            // 用偏移后的坐标去取该位置细胞的状态, 如果存活，本细胞周围存活细胞数+1
                            // 注意：偏移后坐标不能越界（不能超过面板边界）
                            if ((r >= 0 && c >= 0) && (r < rows && c < cols) && copyBoard[r][c] == 1) {
                                aliveNb += 1;
                            }
                        }
                    }
                }
                // 更新细胞状态
                // 1.活细胞，周边存活数小于2，细胞死亡
                // 3.活细胞，周边活细胞超过三个，细胞死亡
                if (copyBoard[i][j] == 1 && (aliveNb < 2 || aliveNb > 3)) {
                    // 改变原数组内容
                    board[i][j] = 0;
                }
                // 2.活细胞，周边存活细胞数2-3个，细胞存活 (不用管，反正都是活的)
                // 4.死细胞，周边存活数正好3个，细胞复活
                if (copyBoard[i][j] == 0 && aliveNb == 3) {
                    // 改变原数组内容
                    board[i][j] = 1;
                }
            }
        }
    }

    /**
     * todo 方法二 复定义复合状态
     */
    public void funcTow(int[][] board) {
        // 定义搜索方向坐标偏移量数组
        int[] nb = {0, 1, -1};

        // 初始化面板行列
        int rows = board.length;
        int cols = board[0].length;

        // 遍历每一个细胞
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {

                // 初始化本细胞周围存活细胞数
                int aliveNb = 0;

                //开始从本细胞不同方向去搜寻周边细胞 ,根据坐标偏移量数组nb[0,1,-1]实现八个方向搜索
                for (int x = 0; x < 3; x++) {
                    for (int y = 0; y < 3; y++) {
                        // 取出坐标偏移量，以获得周围细胞数据
                        // 横坐标纵坐标偏移量不能同时为0 否则就没意义（没有移动）
                        if (!(nb[x] == 0 && nb[y] == 0)) {
                            // 横坐标偏移量
                            int r = i + nb[x];
                            // 纵坐标偏移量
                            int c = j + nb[y];

                            // 用偏移后的坐标去取该位置细胞的状态, 如果存活，本细胞周围存活细胞数+1
                            // 注意：偏移后坐标不能越界（不能超过面板边界）
                            if (
                                    (r >= 0 && c >= 0) &&
                                            (r < rows && c < cols) &&
                                            (board[r][c] == 1 || board[r][c] == 20)
                            ) {
                                // 条件注意：（状态转换由下面两个条件语句控制）
                                // 复合状态21表示之前是死的，活了就变为21（根据下面条件得）
                                // 复合状态20表示之前是活的，现在死掉了

                                aliveNb += 1;
                            }
                        }
                    }
                }
                // 更新细胞状态
                // 1.活细胞，周边存活数小于2，细胞死亡
                // 3.活细胞，周边活细胞超过三个，细胞死亡
                if (
                        (board[i][j] == 1 || board[i][j] == 21) &&
                                (aliveNb < 2 || aliveNb > 3)
                ) {
                    // 改变原数组内容 死掉 复合状态20 过去是活的
                    board[i][j] = 20;
                }
                // 2.活细胞，周边存活细胞数2-3个，细胞存活 (不用管，反正都是活的)

                // 4.死细胞，周边存活数正好3个，细胞复活
                if (
                        (board[i][j] == 0 || board[i][j] == 20) &&
                                aliveNb == 3
                ) {
                    // 改变原数组内容 活着复合状态21 过去是死的
                    board[i][j] = 21;
                }
            }
        }

        // 搜寻结束，回归复合状态 （把数组中20、21转换成0、1）
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (board[i][j] == 20 || board[i][j] == 0) {
                    board[i][j] = 0;
                }
                if (board[i][j] == 21 || board[i][j] == 1) {
                    board[i][j] = 1;
                }
            }
        }
    }
}

```




