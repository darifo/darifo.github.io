---
title: 【笔试题目】搜寻岛屿
date: 2020-3-27 00:00:00
categories: 
- 笔试题
tags:
- 查找
- 数组
- DFS
---


在一个地图中，找出一共多少个岛屿。用一个二维数组表示的地图，图中1代表陆地，0代表水域。一个岛屿是由上下左右相连的陆地，并且被水域包围的区域。


![](/images/11abba423afccace7551ba1ba3042fa.png)


分析这道题，其实就是对二维数组的遍历处理，至于怎么遍历，题目阐述了连续的1是陆地，我们要找多少岛屿，就是找连续上下左右都是1的块有多少，因此想到递归方式，从某一个坐标开始向不同方向去搜寻，看挨着的是不是陆地1，直到遇到水域或者越界，某次递归终结。更为专业的说法叫做对数组进行深度优先搜寻（DFS），统计进行了多少层搜索。


注：由于对二维数组进行DFS扫描时，肯定会存在重复对某一元素操作的情况，为了消除重复扫描步骤，这里使用一个访问记录表visited去存储某一个元素是否已经扫描过，大大降低时间复杂度及其不必要的操作。某一点（i，j）向四个方向分别是：（i+1,j）、（i-1,j）、（i,j+1）、（i,j-1），注意控制数组边界。



```java

package com.company.darifo.solutions;

import java.util.Scanner;

/**
 * 在一个地图中，找出一共多少个岛屿。二维数组 1表示陆地 0表示水域。
 * */
public class FindIslands {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.println("请输入矩阵行数：");
        int x = scanner.nextInt();
        System.out.println("请输入矩阵列数：");
        int y = scanner.nextInt();
        char[][] map = new char[x][y];
        for (int i = 0; i < x; i++) {
            for (int j = 0; j < y; j++) {
                System.out.println("请输入第" + i + "行，第" + j + "列元素：");
                char in = scanner.next().charAt(0);
                System.out.println(in);
                if (in != '0' && in != '1') {
                    System.out.println("输入有误，只能输入0或1，请重新输入：");
                    j--;
                } else {
                    map[i][j] = in;
                }
            }
        }
        printMap(map);
        System.out.println("岛屿数量总共：");
        System.out.println(numsOfIsland(map));
    }

    /**
     * 遍历数组元素，计算岛屿个数
     */
    public static int numsOfIsland(char[][] map) {
        if (map != null) {
            int count = 0;
            //  初始化一个同地图大小的布尔类型备忘录数组，用于记录已被扫描的元素
            boolean[][] visited = new boolean[map.length][map[0].length];
            for (int i = 0; i < map.length; i++) {
                for (int j = 0; j < map[i].length; j++) {
                    // 遇到元素 1 并且没有被扫描到的，进行深度优先搜寻，同时岛屿计数增加
                    if (map[i][j] == '1' && !visited[i][j]) {
                        dfs(map, visited, i, j);
                        count++;
                    }
                }
            }
            return count;
        }
        return -1;
    }

    /**
     * 深度优先递归函数 扫描当前位置上下左右四个方向是否存在陆地
     */
    private static void dfs(char[][] map, boolean[][] visited, int i, int j) {
        // 是陆地并且没有被扫描
        if (map[i][j] == '1' && !visited[i][j]){
            visited[i][j] = true;
            if (i != 0)
                dfs(map, visited, i - 1, j);
            if (i != map.length - 1)
                dfs(map, visited, i + 1, j);
            if (j != 0)
                dfs(map, visited, i, j - 1);
            if (j != map[i].length - 1)
                dfs(map, visited, i, j + 1);
        }
    }

    /**
     * 打印数组地图
     */
    private static void printMap(char[][] map) {
        System.out.println("矩阵打印如下：");
        for (char[] chars : map) {
            for (char aChar : chars) {
                System.out.print(aChar);
                System.out.print('\t');
            }
            System.out.print('\n');
        }
    }
}
```