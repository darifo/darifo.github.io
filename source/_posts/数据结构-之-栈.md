---
title: '数据结构 之 栈 '
author: Darifo
Github: 'https://github.com/darifo'
Pages: 'https://darifo.github.io/'
date: 2020-04-12 12:39:23
categories:
- 数据结构
tags:
- 栈
---


### 定义

栈 是一种最常用和最重要的数据结构之一。

二叉树算法中大量使用到栈，通常将递归算法转换成非递归算法时也需要用到栈。

- 栈 是一种只能在一端进行插入或者删除操作的 **线性表**
- 栈顶：允许进行插入、删除操作的一端，栈顶的当前位置是动态的
- 空栈：没有数据元素
- 压栈（进栈）：插入操作
- 退栈（出栈）：删除


线性表 主要由 顺序表示 或 链式表示。在实际应用中，常以栈、队列、字符串等特殊形式使用。

顺序表示指的是用一组地址连续的存储单元依次存储线性表的数据元素，称为线性表的顺序存储结构或顺序映像。

链式表示指的是用一组任意的存储单元存储线性表中的数据元素，称为线性表的链式存储结构。它的存储单元可以是连续的，也可以是不连续的。

    注：数据的 物理存储结构 分为以下四种，
    
    1.顺序存储 ：

        用一组地址连续的存储单元依次存储线性表的各个数据元素，
        称作 线性表 的顺序存储结构

    2.链接存储 
    
        用一组任意的存储单元存储线性表的数据元素(这组存储单元可以是连续的,也可以是不连续的)。

    3.索引存储 
    
        除建立存储结点信息外，还建立附加的索引表来标识结点的地址。
        索引表由若干索引项组成。

    4.散列存储

        散列存储，又称hash存储，是一种力图将数据元素的存储位置与关键码之间建立确定对应关系的查找技术。
        由节点的关键码值决定节点的存储地址。
        散列法又被成为关键字——地址转换法。


    顺序结构和链接结构适用在内存结构中。

    索引结构和散列结构适用在外存与内存交互结构。

### 特点

- 先入后出，后入先出
- 只允许在栈顶操作元素


### 实现


![](/images/stack.png)


栈的基本操作有： 插入（压栈）、删除（出栈）、判断为空、查找元素等



- 顺序存储结构（顺序栈）

分配一块连续存储区域来存储栈中元素，并用一个变量指向 栈顶元素

![](/images/20200412171841.png)

顺序栈要点：

1、栈顶指针 top 

2、栈最大大小 MaxSize



具体代码：

```java
class MyStack {
    /* Java program to implement basic stack */
    static final int MAX = 1000;  // Maximum size of Stack
    int top; // 栈顶
    int[] a = new int[MAX]; // 线性存储空间申请

    boolean isEmpty() {
        return (top < 0);
    }

    MyStack() {
        top = -1;
    }

    void push(int x) {
        if (top >= (MAX - 1)) {
            System.out.println("Stack Overflow");
        } else {
            a[++top] = x;  // 首次 top = （-1 + 1） = 0 开始存入
        }
    }

    int pop() {
        if (top < 0) {
            System.out.println("Stack Underflow");
            return 0;
        } else {
            return a[top--]; // 出栈，栈顶往下移动
        }
    }
}
```

其实java中util包里面有专门的 Stack 泛型类实现的栈 比较强大, 继承了Vector：

```java
public
class Stack<E> extends Vector<E> {
    /**
     * Creates an empty Stack.
     */
    public Stack() {
    }

    public E push(E item) {
        addElement(item);

        return item;
    }

    public synchronized E pop() {
        E       obj;
        int     len = size();

        obj = peek();
        removeElementAt(len - 1);

        return obj;
    }  

    public synchronized E peek() {
        int     len = size();

        if (len == 0)
            throw new EmptyStackException();
        return elementAt(len - 1);
    }

    public synchronized int search(Object o) {
        int i = lastIndexOf(o);

        if (i >= 0) {
            return size() - i;
        }
        return -1;
    }

    public boolean empty() {
        return size() == 0;
    }
}
```

这里看不到具体存储定义，再往上 看 Vector 代码：

```java
protected Object[] elementData;

protected int elementCount;

```

可以看到，元素的存储结构 是 对象数组 ，甚至在 Stack 类的 push、pop等方法操作上 加了 synchronized 同步锁，也就是说，操作是线程安全的。



- 链式存储结构（链栈）

优点：不存在栈满上溢的情况

在栈的链式结构实现中，一般把链表的头指针做为栈顶

![](/images/20200412184416.png)

链栈要点：

1、栈顶指针 top

2、下一节点 next


链栈 java 实现代码：

```java
/**
* 链栈结构体
*/
static class StackNode {
    int data;  // 数据
    StackNode next;  // 下一个节点

    StackNode(int data) {
        this.data = data;
    }
}
```

```java
public class StackAsLinkedList {
    // Java Code for Linked List Implementation

    StackNode root;   // 栈顶指针

    public boolean isEmpty() {
        return root == null;
    }

    public void push(int data) {
        StackNode newNode = new StackNode(data);

        if (root == null) {
            root = newNode;
        } else {
            // 这里三行 实现 入栈时 栈顶的移动 【重要】
            StackNode temp = root;  // 定义一个临时指针存储 栈顶指针
            root = newNode;  //  栈顶 向后 移动到新元素上
            newNode.next = temp;  // 新元素的下一个节点指向原来的栈顶
        }
    }

    public int pop() {
        int popped = Integer.MIN_VALUE;  // 定义一个最小int值
        if (root == null) {
            System.out.println("Stack is Empty");
        } else {
            popped = root.data; // 相当于删除栈顶数据
            root = root.next; // 把栈顶指针指向下一层元素
        }
        return popped;
    }

    public int peek() {
        if (root == null) {
            System.out.println("Stack is empty");
            return Integer.MIN_VALUE;
        } else {
            return root.data;
        }
    }

    public static void main(String[] args) {

        StackAsLinkedList sll = new StackAsLinkedList();

        sll.push(10);
        sll.push(20);
        sll.push(30);

        System.out.println(sll.pop() + " popped from stack");

        System.out.println("Top element is " + sll.peek());
    }
}
```


### 栈的应用

- 算数表达式求值
- 编译原理（语法分析器等）
- 求解迷宫路径

