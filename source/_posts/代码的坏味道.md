---
title: 代码的坏味道
date: 2019-03-22 11:25:30
categories: 
- 代码规范
tags:
- 规范
---



## 代码的坏味道

1 . Duplicated Code（重复代码）

代码有很多中坏味道，重复是最坏的一种。
一个类中的两个方法有重复代码，可以通过抽取方法将重复代码放到另一个方法中以供调用；
互为兄弟的子类中如果有重复代码，可以将重复代码抽取到父类中；
两个没有关系的类中如果有重复代码，可以重新抽取一个类将重复代码放到这个第三方类中。

2 . Long Method（过长函数）

使用短小的方法首先符合高内聚的要求，同时给方法起一个好的名字，可以帮助理解方法的作用。
如果感觉方法的某个地方需要注释来加以说明，可以把这部分代码放入一个独立的方法中，并以用途（而不是实现手法）来命名方法。

3 . Large Class（过大的类）

类的设计应当遵循单一职责原则（SRP）。重构一个巨大的类可以使用抽取接口的方式来搞清楚这个类应该如何分解。

4 . Long Parameter List（过长参数列表）

比较常见的是将相关的参数组织成一个对象来替换掉这些参数。

5 . Divergent Change（发散式变化）

因为不同的原因，在不同的方向上，修改同一个类。应该分解成更小的类，每个类只因一种原因而修改。
这个深有体会，多层结构系统，开发人员往往容易把全部逻辑都放在Service层，导致Service类非常庞大且不断被修改。

6 . Shotgun Surgery（霰弹式修改）

每遇到变化，需要修改多个类，容易遗漏。应该把需要修改的部分放到一个类里。

7 . Feature Envy（依恋情结）

函数大量地使用了另外类的数据。这种情况下最好将此函数移动到那个类中

8 . Data Clumps（数据泥团）

两个类中相同的字段、函数签名中相同的参数等，都适合提取成一个单独的数据类

9 . Primitive Obsession（基本类型偏执）

如果你有大量的基本数据类型字段，就有可能将其中部分存在逻辑联系的字段组织起来，形成一个类。更进一步的是，将与这些数据有关联的方法也一并移入类中。为了实现这个目标，可以尝试 以类取代类型码(Replace Type Code with Class) 。

如果基本数据类型字段的值是用于方法的参数，可以使用 引入参数对象(Introduce Parameter Object) 或 保持对象完整(Preserve Whole Object) 。

如果想要替换的数据值是类型码，而它并不影响行为，则可以运用 以类取代类型码(Replace Type Code with Class) 将它替换掉。如果你有与类型码相关的条件表达式，可运用 以子类取代类型码(Replace Type Code with Subclass) 或 以状态/策略模式取代类型码(Replace Type Code with State/Strategy) 加以处理。

如果你发现自己正从数组中挑选数据，可运用 以对象取代数组(Replace Array with Object) 。

10 . Switch Statements（switch惊悚现身）

先将switch语句提炼成独立的函数，然后再将此函数搬移到需要多态的类里。

11 . Parallel Inheritance（平行继承体系）

是Shortgun Surgery的一种特殊情况，每当为某个类增加一个子类，必须也为另外一个类相应增加一个子类。例如


蜡笔有大中小三种型号，12种颜色，总共必须有36种蜡笔。
每增加一种颜色，都必须增加大中小三种型号。颜色和型号紧紧耦合在一起。
再来看毛笔，不同的毛笔型号抽象成毛笔，不同颜色抽象成颜料，
毛笔和颜料两个基类形成关联，避免了Shortgun Surgery，这就是Bridge模式。

12 . Lazy Class（冗赘类）

如果一个类不值得存在，那么它就应该消失。

13 . Speculative Generality（夸夸其谈未来性）

如果你的抽象类、委托、方法的参数没有实际的作用，那么就应当被移除掉。

14 . Temporary Field（令人迷惑的暂时字段）

类中某个字段只为某些特殊情况而设置。

15 . Message Chains（过度耦合的消息链）

常常是因为数据结构的层次很深，需要层层调用getter获取内层数据。个人认为Message Chains如果频繁出现，考虑这个字段是否应该移到较外层的类，或者把调用链封装在较外层类的方法。

16 . Middle Man（中间人）

如果一个类的很多功能都通过委托给其他类来完成，那么就不如去掉这些中间人直接和真正负责的对象打交道。

17 . Inappropriate Intimacy（两个类过度亲密）

将双向关联改为单向关联（Change Bidirectional Association to Unidirectional）。
提炼类，将两个类的共同点提炼到新类中，让它们共同使用新类。
继承往往造成过度亲密，运用以委托取代继承（Replace Inheritance with Delegate）。

18 . Alternative Classes（异曲同工的类）

19 . Incomplete Lib Class（不完美的类库）

修改类库的一两个函数 - 引入外部函数（Introduce Foreign Method）
添加一大堆额外行为 - 添加本地扩展（Introduce Local Extension）

20 . Data Class（纯稚的数据类）

数据类不应该把全部字段单纯的通过getter/setter暴露出来（我们在多层结构系统开发时经常这么做），
而应该暴露抽象接口，封装内部结构。
《Clean Code》第六章开始也有讲过同样的问题。

21 . Refused Bequest（被拒绝的遗赠）

子类继承父类的所有函数和数据，子类只挑选几样来使用。
为子类新建一个兄弟类，再运用下移方法（Push Down Method）和下移字段（Push Down Field）把用不到的函数下推个兄弟类。
子类只复用了父类的行为，却不想支持父类的接口。
运用委托替代继承（Replace Inheritance with Delegation）来达到目的。

22 . Comments（过多的注释）
注释不是用来补救劣质代码的，事实上如果我们去除了代码中的所有坏味道，当劣质代码都被移除的时候，注释已经变得多余，因为代码已经讲清楚了一切。



## 重新组织函数


1 . Extract Method 提炼函数

将一段代码放进一个独立函数中，并让函数名称解释该函数的用途。
增加可读性，函数粒度小更容易被复用和覆写。

2 . Inline Method（内联函数）

在函数调用点插入函数本体，然后移除该函数。
函数的本体与名称同样清楚易懂，间接层太多反而不易理解。

3 . Inline Temp（内联临时变量）

将所有对该变量的引用动作，替换为对它赋值的那个表达式自身。

4 . Replace Temp with Query（以查询取代临时变量）

将一个表达式提炼到一个独立函数中，并将临时变量的引用点替换为对函数的调用。
临时变量扩展为查询函数，就可以将使用范围扩展到整个类。
减少临时变量，使函数更短更易维护。

5 . Introduce Explaining Variable（引入解释性变量）

将该复杂表达式的结果放进一个临时变量，以变量名来解释其用途。

6 . Split Temporary Variable（分解临时变量）

针对每次赋值，创造一个独立、对应的临时变量。
临时变量会被多次赋值，容易产生理解歧义。
如果变量被多次赋值（除了“循环变量”和“结果收集变量”），说明承担了多个职责，应该分解。

7 . Remove Assignments to Parameters（移除对参数的赋值）

以一个临时变量取代该参数的位置。
对参数赋值容易降低代码的清晰度；
容易混淆按值传递和按引用传递的方式 ；

8 . Replace Method with Method object 函数对象取代函数

一个大型函数如果包含了很多临时变量，用Extract Method很难拆解，
可以把函数放到一个新创建的类中，把临时变量变成类的实体变量，再用Extract Method拆解。

9 . Substitute Algorithm 替换算法

复杂的算法会增加维护的成本，替换成较简单的算法实现，往往能明显提高代码的可读性和可维护性。


```
作者：高稷
链接：https://www.jianshu.com/p/d91987818ee6
来源：简书
简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。
```